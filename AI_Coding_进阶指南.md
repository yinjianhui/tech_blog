# AI Coding 进阶指南：从 Prompt 到 Agent，掌握未来的编程方式

> 在 AI 时代，程序员的角色正在发生深刻变化。本文将带你深入理解 AI Coding 的核心概念，掌握 Claude Code 的使用技巧，并建立正确的 AI 编程思维。

---

## 前言

你用过 ChatGPT、DeepSeek 这样的 AI 聊天工具，可能觉得它们已经很强大了。但如果我告诉你，这只是冰山一角呢？

真正的 AI Coding 不仅仅是问答，而是让 AI 成为你的编程伙伴——能够理解你的项目、执行复杂任务、甚至自主规划完成目标。

本文将从三个核心概念出发，带你一步步进阶：

- **Prompt**：手动构建上下文
- **Skill**：封装可复用能力，渐进式披露
- **Agent**：自主执行，从聊天工具到任务执行者

准备好了吗？让我们开始。

---

## 第一部分：理解上下文——AI 的"工作记忆"

### 从人类记忆说起

你有没有过这样的经历：有人一口气说了十件事，你只记住了前三件，后面的全忘了？

这就是人类短期记忆的局限性。我们大概只能同时记住 7±2 个东西。

AI 也有类似的"短期记忆"，我们称之为**上下文（Context）**。

```
人类的短期记忆 ≈ AI 的上下文

你可以同时记住 7±2 个东西
AI 可以同时记住 ~200K Token

但是：
├─ 超出容量，信息会被"遗忘"（截断）
├─ 信息越多，处理越慢
└─ 无关信息会干扰判断
```

### AI 上下文的构成

每次对话，AI 能看到的是：

```
┌─────────────────────────────────────────┐
│  System Prompt（你是谁，怎么行为）      │
├─────────────────────────────────────────┤
│  Conversation History（之前说了什么）   │
├─────────────────────────────────────────┤
│  Injected Files（你手动粘贴的代码）     │
├─────────────────────────────────────────┤
│  Tool Outputs（命令执行结果）           │
└─────────────────────────────────────────┘

总计 ≈ Token 预算（如 Claude 3.5 = 200K）
```

### 上下文的两个关键约束

**1. 有限性**
上下文不是无限记忆，有硬上限。超过 200K Token，内容会被截断。

**2. 共享性**
AI 只能看到上下文内的东西，看不到你的"脑子"。

### 实际例子

```
❌ "帮我优化项目性能"
   → AI 不知道你的项目长什么样

✅ "帮我优化这个函数的性能：[粘贴代码]"
   → AI 有了上下文，才能工作
```

**核心洞察**：AI Coding 的本质，就是**管理上下文**的艺术。

---

## 第二部分：三个核心概念

### 2.1 Prompt（提示词）——简单带过

大家都熟悉，就简单说一下。

**定义**：你手动构建的完整上下文

**特点**：
- ✅ 简单直接，适合一次性问答
- ❌ 无法复用，每次都要重新写
- ❌ 上下文容易膨胀

**适用场景**：快速查询、简单问题

---

### 2.2 Skill（技能包）——渐进式披露的力量

#### 什么是 Skill？

```
Skill = 预封装的可复用能力

本质：增强版的 Prompt
├─ 封装了特定任务的处理逻辑
├─ 内置了渐进式披露策略
└─ 可被多次调用
```

#### 核心概念：渐进式披露（Progressive Disclosure）

这是一个关键概念。**不要一次性把所有信息塞给 AI**，而是**按需、分层次**地提供上下文。

```
❌ 一次性披露（常见错误）：
"帮我重构这个电商系统，包括用户模块、订单模块、支付模块、
库存管理、物流跟踪...（粘贴 50 个文件）"

→ 上下文爆炸，AI 无法聚焦

✅ 渐进式披露：
"先帮我规划用户模块的重构步骤"
"好的，现在开始第一步：读取相关代码"
"完成了吗？继续下一步"

→ 每步只给必要上下文，清晰可控
```

#### Skill 的内部逻辑

一个 "写单元测试" Skill 的内部流程：

```
Skill 内部已封装的步骤：

┌─────────────────────────────────┐
│ Step 1: 读取被测函数             │
│         （最小上下文）            │
├─────────────────────────────────┤
│ Step 2: 生成测试用例             │
├─────────────────────────────────┤
│ Step 3: 运行测试，查看结果        │
├─────────────────────────────────┤
│ Step 4: 失败则修复，成功则结束    │
└─────────────────────────────────┘

每一步只加载必要的上下文
```

#### Skill vs Prompt 的对比

| 维度 | Prompt | Skill |
|------|--------|-------|
| **上下文构建** | 手动一次性 | 预封装 + 分步 |
| **复用性** | 无 | 高 |
| **一致性** | 靠运气 | 可保证 |
| **披露方式** | 一次性全部 | 渐进式披露 |
| **适用场景** | 一次性问答 | 重复性任务 |

#### 实际应用：日报生成 Skill

```markdown
name: daily-report
description: 生成工作日报

封装的逻辑：
1. 询问今天完成的工作
2. 询问明天的计划
3. 询问遇到的问题
4. 按模板格式化输出

你只需要说："生成日报"
Skill 会自动按步骤执行
```

**适用场景**：
- 重复性任务（写测试、生成文档）
- 需要一致性的场景
- 可以标准化的工作流

---

### 2.3 Agent（智能体）——从聊天工具到任务执行者

#### 什么是 AI Agent？

**学术定义**（来自《人工智能：现代方法》）：

```
An agent is anything that can perceive its environment 
through sensors and act upon that environment through actuators.

翻译：
任何能够通过传感器感知环境，并通过执行器对环境
产生影响的实体，都可以称为 Agent。
```

**工程实践中的定义**：

```
AI Agent = 赋予 LLM 与外部系统交互的能力

核心转变：
┌─────────────────────────────────────────┐
│           传统聊天 AI                    │
│   只能：输入文本 → 生成文本              │
├─────────────────────────────────────────┤
│           AI Agent                      │
│   可以：感知环境 → 决策 → 执行 → 循环   │
└─────────────────────────────────────────┘
```

#### 为什么需要 AI Agent？

**传统聊天式 AI 的局限**：

早期使用方式：Web/移动端 → 文本聊天 → ChatGPT/豆包

```
交互模式：
用户输入文本 → LLM 生成文本 → 一次性响应 → 结束
```

**核心问题**：
| 局限 | 具体表现 |
|------|----------|
| **无法访问本地环境** | 看不到你的文件、跑不了代码 |
| **无法调用系统资源** | 不能执行命令、不能调 API |
| **无法管理任务状态** | 做完一次响应就退出，不管后续 |
| **被局限在聊天窗口** | 有能力但用不出来 |

**一个形象的类比**：

```
传统聊天 AI = 一个超级聪明的顾问
├─ 你问问题，他给答案
├─ 但他不能动手帮你做
└─ 离开聊天窗口，他就"消失"了

AI Agent = 一个超级聪明的执行者
├─ 不仅懂怎么做
├─ 还能自己动手执行
└─ 持续工作，直到任务完成
```

#### Agent 的执行模式

**传统模式 vs Agent 模式**：

```
传统聊天 AI：
用户输入 → 模型推理 → 输出结果 → 结束
         ↓
    一次性响应，不参与后续
```

```
AI Agent：
感知环境 → 生成决策 → 执行动作 → 更新状态
    ↓                              ↑
    └────────← 再次感知 ←──────────┘

持续循环，直到任务完成
```

**核心差异**：

| 维度 | 传统聊天 AI | AI Agent |
|------|-------------|----------|
| **执行模式** | 一次性 request-response | 持续 control loop |
| **LLM 角色** | 文本生成器 | 决策组件 |
| **能力范围** | 只能生成文本 | 可以执行操作 |
| **状态管理** | 无 | 维护任务进度 |

#### Agent 的核心组件

```
┌─────────────────────────────────────────────┐
│              AI Agent 架构                  │
├─────────────────────────────────────────────┤
│                                             │
│  ┌───────────┐     ┌──────────────────┐   │
│  │   LLM     │────→│   工具接口       │   │
│  │ (决策层)  │     │  - 文件操作      │   │
│  │           │←────│  - API 调用      │   │
│  └───────────┘     │  - 系统命令      │   │
│       ↓            │  - 外部服务      │   │
│       │            └──────────────────┘   │
│       ↓                    ↓              │
│  ┌─────────────────────────────────┐     │
│  │         状态管理                │     │
│  │  - 任务进度                     │     │
│  │  - 已执行步骤                   │     │
│  │  - 环境状态                     │     │
│  │  - 历史决策                     │     │
│  └─────────────────────────────────┘     │
│       ↓                                    │
│  ┌─────────────────────────────────┐     │
│  │         控制器 (骨架)            │     │
│  │  - 驱动循环                      │     │
│  │  - 解析模型输出                  │     │
│  │  - 调用工具                      │     │
│  │  - 处理异常                      │     │
│  │  - 判断是否继续                  │     │
│  └─────────────────────────────────┘     │
└─────────────────────────────────────────────┘
```

**组件说明**：

| 组件 | 职责 | 类比 |
|------|------|------|
| **LLM** | 理解目标、分析状态、生成决策 | 大脑 |
| **工具接口** | 将决策转为实际操作（文件、API、命令） | 手脚 |
| **状态管理** | 维护任务进度、历史记录 | 记忆 |
| **控制器** | 驱动循环、解析输出、异常处理 | 中枢神经 |

#### Agent 的工作流程

一个完整任务执行循环：

```
1. 接收任务目标
   "重构登录模块并确保测试通过"

2. 将目标与当前状态输入 LLM
   状态：还未开始，需要先了解代码结构

3. LLM 输出下一步行动计划
   "先读取 login.js，了解当前实现"

4. 控制器解析输出
   识别到：需要执行文件读取操作

5. 调用相应工具执行
   读取 login.js 内容

6. 更新状态
   状态：已读取 login.js，发现代码有 200 行

7. 判断是否完成任务
   未完成，继续下一步

8. 进入下一轮循环
   LLM：现在分析代码，生成重构方案...
```

#### 为什么 Agent 是革命性的？

**关键价值**：

> AI Agent 不是提升了 LLM 的智能水平，而是**赋予了它与外部系统交互的能力**，使其能够参与到真实的工作流程之中。

从本质上说，这是 AI 应用在客户端方面的一次**角色转变**：
- 从单纯的答题工具
- 到可以参与任务执行的系统组件

**架构层面的转变**：

```
传统应用架构：
用户 → 界面 → 后端逻辑 → 数据库/服务

Agent 架构：
用户 → Agent → (LLM决策 + 工具执行) → 完成任务
```

**生产力的释放**：

```
之前：
├─ LLM 只能生成文本
├─ 你需要手动复制代码
└─ 自己运行、调试、修复

现在：
├─ Agent 自己规划步骤
├─ 自动调用工具执行
└─ 持续迭代直到完成
```

**适用场景**：
- 复杂工作流（重构、迁移）
- 需要多步骤的任务
- 需要与外部系统交互

---

### 2.4 三个概念的对比分析

#### 层次关系

```
上下文管理的演进史：

Prompt  → Skill  → Agent
  ↓         ↓         ↓
手写     封装     自主化
单次     复用     规划化

┌─────────────────────────────────────────┐
│              Agent                      │
│   处理复杂任务，需要自主规划 + 执行       │
│   例子：重构整个模块并测试               │
├─────────────────────────────────────────┤
│              Skill                      │
│   封装常见任务，渐进式披露上下文          │
│   例子：写单元测试、生成文档             │
├─────────────────────────────────────────┤
│              Prompt                     │
│   一次性问答，手动构建上下文             │
│   例子：解释概念、调试代码               │
└─────────────────────────────────────────┘
```

#### 详细对比表

| 维度 | Prompt | Skill | Agent |
|------|--------|-------|-------|
| **定义** | 手动构建的上下文 | 预封装的能力包 | 自主执行系统 |
| **上下文策略** | 手动一次性构建 | 预封装 + 渐进式披露 | 动态按需加载 |
| **披露方式** | 一次性全部 | 渐进式分步 | 按需动态 |
| **复用性** | 无 | 高 | 高 |
| **自主性** | 被动响应 | 半自动 | 全自主 |
| **工具能力** | 无 | 可选 | 必需 |
| **状态管理** | 无 | 简单 | 完整 |
| **执行模式** | 单次响应 | 预定义流程 | 持续循环 |
| **适用场景** | 问答、简单问题 | 重复性任务 | 复杂工作流 |

#### 如何选择？

```
任务类型判断流程：

1. 是一次性问答吗？
   → YES → 用 Prompt

2. 是重复性任务吗？
   → YES → 用 Skill

3. 是复杂的多步骤任务吗？
   → YES → 用 Agent

实际应用：
├─ 解释概念 → Prompt
├─ 写单元测试 → Skill
├─ 重构模块 → Agent
```

#### 为什么会有这些技术？

**根本矛盾**：

```
有限的上下文窗口  vs  复杂的任务需求

┌─────────────────────────────────┐
│  200K Token 看起来很多          │
│  但大型项目轻松超过：           │
│                                 │
│  - 代码文件（几十个）           │
│  - 历史对话（累积）             │
│  - 文档说明                     │
│  - 配置文件                     │
└─────────────────────────────────┘
```

**技术演进的逻辑**：

```
问题 1：每次都要重复写相似指令
→ 解决：Skill（封装 + 复用）

问题 2：复杂任务无法一次性完成
→ 解决：渐进式披露（分步提供上下文）

问题 3：AI 无法主动获取信息
→ 解决：Agent（工具调用 + 动态规划）

问题 4：上下文太长，效率下降
→ 解决：/compact + /clear（清理历史）
```

**终极目标**：

> 用最少的上下文，完成最多的任务

---

## 第三部分：Claude Code 实战指南

Claude Code 是 Anthropic 推出的 AI 编程 Agent，它在终端运行，能够真正帮你写代码。

### 3.1 环境搭建与基础交互

#### 安装与登录

```bash
# 安装
npm install -g @anthropic-ai/claude-code

# 初始化项目
mkdir my-todo
cd my-todo
claude

# 首次使用需登录（如未自动提示）
/login
```

**登录模式**：
- **订阅制**：Claude Pro/Max 会员直接授权
- **API Key**：按量付费，配置 API Key
- **提示**：可通过环境变量配置国产模型（GLM、MiniMax 等）

#### 三种核心模式

| 模式 | 切换方式 | 特点 | 适用场景 |
|------|----------|------|----------|
| **默认模式** | Shift + Tab | 每次操作都询问，显示 "Press ? for shortcuts" | 新手、不确定时 |
| **自动模式** | Shift + Tab | 显示 "accept edit on"，自动执行文件操作 | 快速开发 |
| **规划模式** | Shift + Tab | 显示 "Plan mode"，只讨论方案不修改文件 | 复杂任务、架构调整 |

#### 基础操作技巧

**多行输入**：
- `Shift + Enter` 换行

**使用编辑器输入**：
- `Ctrl + G` 打开 VS Code 临时窗口编辑，适合长指令

**打开文件预览**：
```bash
!open index.html  # 直接打开文件
!npm run dev      # 执行任何 Shell 命令
```

---

### 3.2 进阶开发工作流

#### 复杂任务与 Plan Mode

**场景**：架构重构（如 HTML → React+TS+Vite）

```
步骤：
1. 切换到 Plan Mode
2. 输入需求
3. Claude 生成详细执行计划
4. 你可以选择：
   ✓ 同意并自动执行
   ✓ 同意但每步询问
   ✓ 修改计划（增加功能、调整方案）
```

#### 终端权限与后台任务

**权限控制**：
- 自动模式下，终端命令（如 `npm install`）仍需确认
- 跳过权限检测：`claude --dangerously-skip-permissions`（风险自负）

**后台任务管理**：
```bash
# 场景：运行阻塞型命令（如启动服务器）

Ctrl + B    # 将任务挂起到后台
/tasks      # 查看后台任务
k           # 终止任务
```

#### 回滚功能

**操作失误或想撤销**：
```bash
双击 Esc 或 /rewind

选择回滚点：
├─ 代码 + 对话一起回滚
├─ 仅回滚对话
└─ 仅回滚代码

注意：只能回滚 Claude 写入的文件
      mkdir、npm install 等终端命令生成的文件无法回滚
      建议配合 Git 使用
```

---

### 3.3 高级扩展

#### Hooks (自动化钩子)

**用途**：在工具执行前后自动运行脚本（如自动格式化）

```bash
配置：/hook

示例：代码自动格式化
├─ 触发时机：post-tool-use
├─ 工具：write、edit
└─ 命令：利用 jq 解析文件路径并传给 Prettier

配置位置：
├─ 项目级：settings.json（团队共享）
└─ 用户级：全局配置
```

#### Skills (自定义技能)

**本质**：动态 Prompt 或说明书

```bash
创建位置：
├~/.claude/skills              # 全局
└项目目录/.claude/skills        # 项目级

结构：
├─ name: 技能名称
├─ description: 描述（用于自动匹配）
└─ 指令: Markdown 格式的具体内容

使用：
/skills        # 查看可用技能
/skill-name    # 主动调用
```

**示例：日报生成 Skill**
```markdown
name: daily-report
description: 生成工作日报

内容：
请按照以下模板生成日报：
## 今日完成
-
## 明日计划
-
## 遇到的问题
-
```

#### SubAgents (子智能体)

**概念**：独立的 Agent，拥有独立上下文窗口

| 维度 | Skill | SubAgent |
|------|-------|----------|
| **上下文** | 共享主会话 | 独立窗口 |
| **Token 消耗** | 会爆炸 | 隔离，保持干净 |
| **适用场景** | 轻量任务 | 复杂、高要求任务 |

**创建与使用**：
```bash
/agents -> Create new agent

配置：
├─ 名称：如 "代码审查专家"
├─ 描述：明确职责
├─ 工具：限制可用工具（如只读）
├─ 模型：选择模型
└─ 颜色：标识

典型场景：代码审查
→ SubAgent 独立审查，不污染主会话
→ 仅返回结果，保持主会话干净
```

#### Plugins (插件)

**本质**：Skills + SubAgents + Hooks 的全家桶

```bash
管理：/plugin

功能：
├─ Discover：发现插件（如 frontend-design）
├─ Install：一键安装整套能力
└─ 配置：自动注入所有相关能力

示例：frontend-design 插件
→ 安装后，Claude 自动获得 Anthropic 官方沉淀的
   前端设计直觉，生成更现代美观的 UI
```

---

### 3.4 多模态能力

#### 图片与设计稿还原

**直接粘贴图片**：
```bash
拖入设计稿图片
或 Ctrl + V 粘贴（macOS 也是 Ctrl+V）
```

**使用 MCP (Model Context Protocol) 精确还原 Figma**：
```bash
1. 安装 Figma MCP Server（需 Figma Access Token）
2. /c 恢复上下文
3. /mcp 确认工具已加载
4. 输入需求 + Figma 链接
   → Claude 自动获取图层、间距、字体等信息
```

---

## 第四部分：Vibe Coding 核心原则

这些原则适用于所有 AI 编程工具，不仅限于 Claude Code。

### 4.1 Plan First，Don't Hope

```
❌ 错误做法：
"帮我重构整个项目"
→ 期待奇迹发生

✅ 正确做法：
"先规划如何重构这个模块，列出步骤"
→ 强制规划再执行
```

**核心思想**：不要给一个宏大的目标期待奇迹发生，而是把大的目标一步步拆解成小目标。

---

### 4.2 维护 CLAUDE.md（项目规范与记忆）

**CLAUDE.md 是什么？**

```bash
AI 的"记忆文件" = 项目规范 + 代码风格 + 常用命令

创建：/init 自动生成
管理：/memory 编辑记忆文件

级别：
├─ 项目级（当前目录生效）
└─ 用户级（全局生效）
```

**放什么内容？**

```markdown
## 项目规范
- 代码风格：2 空格缩进
- 命名规范：camelCase
- 测试要求：覆盖率 > 80%

## 架构决策
- 使用 React + TypeScript
- 状态管理：Zustand
- 样式方案：Tailwind CSS

## 常用命令
- 启动开发：npm run dev
- 运行测试：npm test
- 构建部署：npm run build

## 历史踩坑
- 注意：XX 组件在 Safari 下有兼容问题
- TODO：待优化 YY 性能
```

**为什么重要？**
- 让 AI 快速理解项目上下文
- 保证代码风格一致性
- 避免 AI 重复犯错

---

### 4.3 /compact + /clear 组合拳（上下文管理）

**场景**：聊天历史太长，上下文膨胀

```bash
操作流程：
1. /compact  # 总结关键点，保留重要信息
2. /clear    # 清空当前会话记忆
3. 粘贴摘要  # 重新开始，只保留必要上下文
```

**为什么需要？**

```bash
上下文太长的问题：
├─ AI 推理速度变慢
├─ Token 成本增加
└─ 历史噪音干扰判断

/compact + /clear 的效果：
├─ 总结关键决策
├─ 清除冗余历史
└─ 保持上下文精简高效
```

---

### 4.4 Plan → Execute → Review 循环

```bash
每个小任务都要闭环：

Plan：先规划
  ↓
Execute：执行
  ↓
Review：检查 diff，确认正确
  ↓
Loop：进入下一个任务
```

**关键点**：
- 不要盲目相信 AI 的输出
- 必须检查 diff
- 出错要及时修正

---

### 4.5 复杂任务拆解

```bash
大任务 → Sub-task 1, 2, 3 → 每个独立规划

❌ 错误：
"帮我重构整个电商系统（粘贴 50 个文件）"

✅ 正确：
"先规划用户模块的重构"
"完成了吗？继续订单模块"
"最后处理支付模块"
```

**核心思想**：把复杂任务拆成多个小任务，每个小任务都让 AI 独立规划。

---

### 4.6 控制上下文长度

```bash
只放必要的文件：
├─ 精读：核心模块
├─ 跳过：第三方库
└─ 删除：无关代码

定期清理历史：
├─ /compact 总结
├─ /clear 清空
└─ 重新开始新任务
```

**为什么？**
- 上下文越长，效果越差
- Token 限制（200K 不是无限）
- 成本考虑

---

## 第五部分：AI 时代的软件工程

> 来源：Google Cloud AI 总监 Addy Osmani

### 核心观点

**AI 不会消灭程序员，但会淘汰"只会写代码的码农"**

---

### 5.1 四大关键变化

#### 变化 1：初级程序员岗位的门槛变高了

**过去**：
```
入行路径：
├─ 搬砖写基础代码
├─ 做增删改查
└─ 慢慢积累经验
```

**现在**：
```
AI 能干的：
├─ 自动生成基础代码
├─ 写测试用例
└─ 修复常见 bug

新人必须学会：
├─ 用 AI 一个人顶一个团队
├─ AI 替代不了的能力
│   ├─ 沟通协调
│   ├─ 业务拆解
│   └─ 底层思考
└─ 从 "码农" 升级为 "开发者"
```

**核心启示**：

> 不要和 AI 比写代码的速度，要比 AI 更懂业务、更会思考。

---

#### 变化 2：程序员从"码农"变成"AI 监工"

**角色转变**：

```
过去：自己写代码
├─ 写得快 = 竞争力
└─ 熟练度 = 价值

现在：管理 AI 写代码
├─ 不需要写得最快
├─ 但必须能一眼看出 AI 的坑
│   ├─ 逻辑错误
│   ├─ 安全漏洞
│   └─ 性能问题
└─ 审查能力 > 编码能力
```

**类比**：

```
传统模式：
程序员 ──编写代码──> 产品

AI 时代：
程序员 ──指挥 AI──> 代码 ──审查──> 产品
         ↑                    ↑
      怎么问更关键          怎么查更重要
```

---

#### 变化 3：通才比专才更吃香——T 型人才的崛起

**过去的技术栈壁垒**：

```
前端工程师 ←→ 后端工程师
    隔山如隔山
```

**AI 时代的跨界能力**：

```
T 型人才：
├─ 一横：广泛的知识面
│   ├─ 前端
│   ├─ 后端
│   ├─ 数据库
│   └─ 部署运维
└─ 一竖：核心专长（深度）
```

**实际能力**：

```
有了 AI 辅助：
后端也能快速搞定前端
前端也能写出合理的后端

核心竞争力：
├─ 不是 "我只懂 React"
├─ 而是 "我能用 AI 快速解决从数据库到 UI 的一整套问题"
└─ 全栈思维 + AI 加速
```

---

#### 变化 4：行业阵痛期，但也孕育新机会

**挑战**：

```
├─ 大厂招人变少了
├─ 纯编码岗位在萎缩
└─ 门槛变高了
```

**机会**：

```
AI 让软件开发进入各行各业：
├─ 医疗：AI 辅助诊断系统
├─ 农业：智能灌溉、病虫害识别
├─ 制造：自动化质检
├─ 教育：个性化学习
└─ 金融：风控、量化交易

程序员的新战场：
不再局限于科技公司
而是用 AI 解决更复杂的业务难题
```

**核心洞察**：

```
过去：做 CRM、做电商、做社交
现在：用 AI 重塑每个行业

机会不在 "写更好的代码"
而在 "用代码解决更好的问题"
```

---

### 5.2 我们该怎么做？

#### 给个人的建议

```
1. 拥抱 AI，而不是抵触
   └─ 早学早受益，慢一步就落后

2. 培养 AI 替代不了的能力
   ├─ 业务理解
   ├─ 系统设计
   ├─ 沟通协调
   └─ 批判性思维（能看出 AI 的坑）

3. 成为 T 型人才
   ├─ 一个核心专长（深度）
   └─ 广泛的知识面（广度）
   └─ 用 AI 快速跨界

4. 终身学习
   ├─ 关注 AI 新动态
   ├─ 实践新工具
   └─ 建立自己的 AI 工具箱

5. 关注 AI 落地的项目
   ├─ 不只是 "用过 ChatGPT"
   ├─ 而是 "用 AI 解决了实际问题"
   └─ 建立作品集，展示能力
```

#### 给团队的建议

```
1. 建立 AI 编程规范
   └─ CLAUDE.md、Code Review 流程

2. 鼓励实验和分享
   └─ 定期技术分享（就像今天！）

3. 投资于工具
   └─ Claude Code、Copilot、Cursor

4. 重新定义岗位能力
   └─ 从 "写代码快" 到 "用 AI 快速交付"

5. 培养全栈思维
   └─ 打破前后端壁垒
```

---

## 结语

```
AI 不会取代程序员，
但会用 AI 的程序员会取代不会用的。

未来两年的软件工程：
├─ 不是人和 AI 竞争
├─ 而是会用 AI 的人 vs 不会用 AI 的人
└─ 你在哪一边？

今天学到的这些：
├─ Claude Code
├─ Agent 思维
├─ Vibe Coding 原则
└─ AI 时代的工程思维

就是你的竞争优势。

从今天开始：
✓ 用 AI 写代码
✓ 用 AI 思考问题
✓ 用 AI 解决更复杂的问题

Happy Coding! 🚀
```

---

## 附录：快速参考

### 常用命令速查

```bash
# Claude Code
claude              # 启动
/login              # 登录
/plan               # 切换规划模式
/compact            # 压缩上下文
/clear              # 清空上下文
/rewind             # 回滚
/memory             # 编辑记忆文件
/skills             # 查看技能
/agents             # 管理子智能体
/hooks              # 配置钩子
/plugins            # 管理插件

# 快捷键
Shift + Tab         # 切换模式
Ctrl + G            # 打开编辑器
Ctrl + B            # 后台任务
Esc Esc             # 回滚
```

### 推荐学习资源

- **Claude Code 官方文档**：https://docs.anthropic.com
- **Cursor 编辑器**：https://cursor.sh
- **GitHub Copilot**：https://github.com/features/copilot

---

**感谢阅读！**

如果你觉得这篇文章对你有帮助，欢迎分享给更多人。有任何问题，欢迎交流讨论 🎉
